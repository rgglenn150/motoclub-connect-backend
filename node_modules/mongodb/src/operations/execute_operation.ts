import type { Document } from '../bson';
import {
<<<<<<< HEAD
  isRetryableError,
=======
  isRetryableReadError,
  isRetryableWriteError,
>>>>>>> ee46ff854c6138d16fc5fe7b13fd0cd6ffcece5a
  MongoCompatibilityError,
  MONGODB_ERROR_CODES,
  MongoError,
  MongoExpiredSessionError,
  MongoNetworkError,
<<<<<<< HEAD
  MongoRuntimeError,
  MongoServerError,
  MongoTransactionError
} from '../error';
=======
  MongoNotConnectedError,
  MongoRuntimeError,
  MongoServerError,
  MongoTransactionError,
  MongoUnexpectedServerResponseError
} from '../error';
import type { MongoClient } from '../mongo_client';
>>>>>>> ee46ff854c6138d16fc5fe7b13fd0cd6ffcece5a
import { ReadPreference } from '../read_preference';
import type { Server } from '../sdam/server';
import {
  sameServerSelector,
  secondaryWritableServerSelector,
  ServerSelector
} from '../sdam/server_selection';
import type { Topology } from '../sdam/topology';
import type { ClientSession } from '../sessions';
<<<<<<< HEAD
import { Callback, maxWireVersion, maybePromise, supportsRetryableWrites } from '../utils';
=======
import { Callback, maybePromise, supportsRetryableWrites } from '../utils';
>>>>>>> ee46ff854c6138d16fc5fe7b13fd0cd6ffcece5a
import { AbstractOperation, Aspect } from './operation';

const MMAPv1_RETRY_WRITES_ERROR_CODE = MONGODB_ERROR_CODES.IllegalOperation;
const MMAPv1_RETRY_WRITES_ERROR_MESSAGE =
  'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';

type ResultTypeFromOperation<TOperation> = TOperation extends AbstractOperation<infer K>
  ? K
  : never;

/** @internal */
export interface ExecutionResult {
  /** The server selected for the operation */
  server: Server;
  /** The session used for this operation, may be implicitly created */
  session?: ClientSession;
  /** The raw server response for the operation */
  response: Document;
}

/**
 * Executes the given operation with provided arguments.
 * @internal
 *
 * @remarks
 * This method reduces large amounts of duplication in the entire codebase by providing
 * a single point for determining whether callbacks or promises should be used. Additionally
 * it allows for a single point of entry to provide features such as implicit sessions, which
 * are required by the Driver Sessions specification in the event that a ClientSession is
 * not provided
 *
 * @param topology - The topology to execute this operation on
 * @param operation - The operation to execute
 * @param callback - The command result callback
 */
export function executeOperation<
  T extends AbstractOperation<TResult>,
  TResult = ResultTypeFromOperation<T>
<<<<<<< HEAD
>(topology: Topology, operation: T): Promise<TResult>;
export function executeOperation<
  T extends AbstractOperation<TResult>,
  TResult = ResultTypeFromOperation<T>
>(topology: Topology, operation: T, callback: Callback<TResult>): void;
export function executeOperation<
  T extends AbstractOperation<TResult>,
  TResult = ResultTypeFromOperation<T>
>(topology: Topology, operation: T, callback?: Callback<TResult>): Promise<TResult> | void;
export function executeOperation<
  T extends AbstractOperation<TResult>,
  TResult = ResultTypeFromOperation<T>
>(topology: Topology, operation: T, callback?: Callback<TResult>): Promise<TResult> | void {
  if (!(operation instanceof AbstractOperation)) {
    // TODO(NODE-3483)
    throw new MongoRuntimeError('This method requires a valid operation instance');
  }

  return maybePromise(callback, cb => {
    if (topology.shouldCheckForSessionSupport()) {
      return topology.selectServer(ReadPreference.primaryPreferred, err => {
        if (err) return cb(err);

        executeOperation<T, TResult>(topology, operation, cb);
=======
>(client: MongoClient, operation: T): Promise<TResult>;
export function executeOperation<
  T extends AbstractOperation<TResult>,
  TResult = ResultTypeFromOperation<T>
>(client: MongoClient, operation: T, callback: Callback<TResult>): void;
export function executeOperation<
  T extends AbstractOperation<TResult>,
  TResult = ResultTypeFromOperation<T>
>(client: MongoClient, operation: T, callback?: Callback<TResult>): Promise<TResult> | void;
export function executeOperation<
  T extends AbstractOperation<TResult>,
  TResult = ResultTypeFromOperation<T>
>(client: MongoClient, operation: T, callback?: Callback<TResult>): Promise<TResult> | void {
  if (!(operation instanceof AbstractOperation)) {
    // TODO(NODE-3483): Extend MongoRuntimeError
    throw new MongoRuntimeError('This method requires a valid operation instance');
  }

  return maybePromise(callback, callback => {
    const topology = client.topology;

    if (topology == null) {
      if (client.s.hasBeenClosed) {
        return callback(
          new MongoNotConnectedError('Client must be connected before running operations')
        );
      }
      client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;
      return client.connect(error => {
        delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];
        if (error) {
          return callback(error);
        }
        return executeOperation<T, TResult>(client, operation, callback);
      });
    }

    if (topology.shouldCheckForSessionSupport()) {
      return topology.selectServer(ReadPreference.primaryPreferred, {}, err => {
        if (err) return callback(err);

        executeOperation<T, TResult>(client, operation, callback);
>>>>>>> ee46ff854c6138d16fc5fe7b13fd0cd6ffcece5a
      });
    }

    // The driver sessions spec mandates that we implicitly create sessions for operations
    // that are not explicitly provided with a session.
<<<<<<< HEAD
    let session: ClientSession | undefined = operation.session;
=======
    let session = operation.session;
>>>>>>> ee46ff854c6138d16fc5fe7b13fd0cd6ffcece5a
    let owner: symbol | undefined;
    if (topology.hasSessionSupport()) {
      if (session == null) {
        owner = Symbol();
<<<<<<< HEAD
        session = topology.startSession({ owner, explicit: false });
      } else if (session.hasEnded) {
        return cb(new MongoExpiredSessionError('Use of expired sessions is not permitted'));
      } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {
        return cb(new MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later'));
      }
    } else if (session) {
      // If the user passed an explicit session and we are still, after server selection,
      // trying to run against a topology that doesn't support sessions we error out.
      return cb(new MongoCompatibilityError('Current topology does not support sessions'));
    }

    try {
      executeWithServerSelection(topology, session, operation, (err, result) => {
        if (session && session.owner && session.owner === owner) {
          return session.endSession(err2 => cb(err2 || err, result));
        }

        cb(err, result);
      });
    } catch (e) {
      if (session && session.owner && session.owner === owner) {
        session.endSession();
      }

      throw e;
=======
        session = client.startSession({ owner, explicit: false });
      } else if (session.hasEnded) {
        return callback(new MongoExpiredSessionError('Use of expired sessions is not permitted'));
      } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {
        return callback(new MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later'));
      }
    } else {
      // no session support
      if (session && session.explicit) {
        // If the user passed an explicit session and we are still, after server selection,
        // trying to run against a topology that doesn't support sessions we error out.
        return callback(new MongoCompatibilityError('Current topology does not support sessions'));
      } else if (session && !session.explicit) {
        // We do not have to worry about ending the session because the server session has not been acquired yet
        delete operation.options.session;
        operation.clearSession();
        session = undefined;
      }
    }

    try {
      executeWithServerSelection<TResult>(topology, session, operation, (error, result) => {
        if (session?.owner != null && session.owner === owner) {
          return session.endSession(endSessionError => callback(endSessionError ?? error, result));
        }

        callback(error, result);
      });
    } catch (error) {
      if (session?.owner != null && session.owner === owner) {
        session.endSession().catch(() => null);
      }

      throw error;
>>>>>>> ee46ff854c6138d16fc5fe7b13fd0cd6ffcece5a
    }
  });
}

<<<<<<< HEAD
function supportsRetryableReads(server: Server) {
  return maxWireVersion(server) >= 6;
}

function executeWithServerSelection(
  topology: Topology,
  session: ClientSession,
  operation: AbstractOperation,
  callback: Callback
) {
  const readPreference = operation.readPreference || ReadPreference.primary;
  const inTransaction = session && session.inTransaction();

  if (inTransaction && !readPreference.equals(ReadPreference.primary)) {
    callback(
=======
function executeWithServerSelection<TResult>(
  topology: Topology,
  session: ClientSession | undefined,
  operation: AbstractOperation,
  callback: Callback<TResult>
) {
  const readPreference = operation.readPreference ?? ReadPreference.primary;
  const inTransaction = !!session?.inTransaction();

  if (inTransaction && !readPreference.equals(ReadPreference.primary)) {
    return callback(
>>>>>>> ee46ff854c6138d16fc5fe7b13fd0cd6ffcece5a
      new MongoTransactionError(
        `Read preference in a transaction must be primary, not: ${readPreference.mode}`
      )
    );
<<<<<<< HEAD

    return;
  }

  if (
    session &&
    session.isPinned &&
    session.transaction.isCommitted &&
    !operation.bypassPinningCheck
  ) {
=======
  }

  if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {
>>>>>>> ee46ff854c6138d16fc5fe7b13fd0cd6ffcece5a
    session.unpin();
  }

  let selector: ReadPreference | ServerSelector;

<<<<<<< HEAD
  if (operation.hasAspect(Aspect.CURSOR_ITERATING)) {
    // Get more operations must always select the same server, but run through
=======
  if (operation.hasAspect(Aspect.MUST_SELECT_SAME_SERVER)) {
    // GetMore and KillCursor operations must always select the same server, but run through
>>>>>>> ee46ff854c6138d16fc5fe7b13fd0cd6ffcece5a
    // server selection to potentially force monitor checks if the server is
    // in an unknown state.
    selector = sameServerSelector(operation.server?.description);
  } else if (operation.trySecondaryWrite) {
    // If operation should try to write to secondary use the custom server selector
    // otherwise provide the read preference.
    selector = secondaryWritableServerSelector(topology.commonWireVersion, readPreference);
  } else {
    selector = readPreference;
  }

  const serverSelectionOptions = { session };
<<<<<<< HEAD
  function callbackWithRetry(err?: any, result?: any) {
    if (err == null) {
      return callback(undefined, result);
    }

    const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);
    const hasWriteAspect = operation.hasAspect(Aspect.WRITE_OPERATION);
    const itShouldRetryWrite = shouldRetryWrite(err);

    if ((hasReadAspect && !isRetryableError(err)) || (hasWriteAspect && !itShouldRetryWrite)) {
      return callback(err);
    }

    if (
      hasWriteAspect &&
      itShouldRetryWrite &&
      err.code === MMAPv1_RETRY_WRITES_ERROR_CODE &&
      err.errmsg.match(/Transaction numbers/)
    ) {
      callback(
        new MongoServerError({
          message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
          errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
          originalError: err
        })
      );

      return;
    }

    // select a new server, and attempt to retry the operation
    topology.selectServer(selector, serverSelectionOptions, (e?: any, server?: any) => {
      if (
        e ||
        (operation.hasAspect(Aspect.READ_OPERATION) && !supportsRetryableReads(server)) ||
        (operation.hasAspect(Aspect.WRITE_OPERATION) && !supportsRetryableWrites(server))
      ) {
        callback(e);
        return;
      }

      // If we have a cursor and the initial command fails with a network error,
      // we can retry it on another connection. So we need to check it back in, clear the
      // pool for the service id, and retry again.
      if (
        err &&
        err instanceof MongoNetworkError &&
        server.loadBalanced &&
        session &&
        session.isPinned &&
        !session.inTransaction() &&
        operation.hasAspect(Aspect.CURSOR_CREATING)
      ) {
        session.unpin({ force: true, forceClear: true });
=======
  function retryOperation(originalError: MongoError) {
    const isWriteOperation = operation.hasAspect(Aspect.WRITE_OPERATION);
    const isReadOperation = operation.hasAspect(Aspect.READ_OPERATION);

    if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {
      return callback(
        new MongoServerError({
          message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
          errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
          originalError
        })
      );
    }

    if (isWriteOperation && !isRetryableWriteError(originalError)) {
      return callback(originalError);
    }

    if (isReadOperation && !isRetryableReadError(originalError)) {
      return callback(originalError);
    }

    if (
      originalError instanceof MongoNetworkError &&
      session?.isPinned &&
      !session.inTransaction() &&
      operation.hasAspect(Aspect.CURSOR_CREATING)
    ) {
      // If we have a cursor and the initial command fails with a network error,
      // we can retry it on another connection. So we need to check it back in, clear the
      // pool for the service id, and retry again.
      session.unpin({ force: true, forceClear: true });
    }

    // select a new server, and attempt to retry the operation
    topology.selectServer(selector, serverSelectionOptions, (error?: Error, server?: Server) => {
      if (!error && isWriteOperation && !supportsRetryableWrites(server)) {
        return callback(
          new MongoUnexpectedServerResponseError(
            'Selected server does not support retryable writes'
          )
        );
      }

      if (error || !server) {
        return callback(
          error ?? new MongoUnexpectedServerResponseError('Server selection failed without error')
        );
>>>>>>> ee46ff854c6138d16fc5fe7b13fd0cd6ffcece5a
      }

      operation.execute(server, session, callback);
    });
  }

  if (
    readPreference &&
    !readPreference.equals(ReadPreference.primary) &&
<<<<<<< HEAD
    session &&
    session.inTransaction()
=======
    session?.inTransaction()
>>>>>>> ee46ff854c6138d16fc5fe7b13fd0cd6ffcece5a
  ) {
    callback(
      new MongoTransactionError(
        `Read preference in a transaction must be primary, not: ${readPreference.mode}`
      )
    );

    return;
  }

  // select a server, and execute the operation against it
<<<<<<< HEAD
  topology.selectServer(selector, serverSelectionOptions, (err?: any, server?: any) => {
    if (err) {
      callback(err);
      return;
=======
  topology.selectServer(selector, serverSelectionOptions, (error, server) => {
    if (error || !server) {
      return callback(error);
>>>>>>> ee46ff854c6138d16fc5fe7b13fd0cd6ffcece5a
    }

    if (session && operation.hasAspect(Aspect.RETRYABLE)) {
      const willRetryRead =
<<<<<<< HEAD
        topology.s.options.retryReads !== false &&
        !inTransaction &&
        supportsRetryableReads(server) &&
        operation.canRetryRead;

      const willRetryWrite =
        topology.s.options.retryWrites === true &&
=======
        topology.s.options.retryReads && !inTransaction && operation.canRetryRead;

      const willRetryWrite =
        topology.s.options.retryWrites &&
>>>>>>> ee46ff854c6138d16fc5fe7b13fd0cd6ffcece5a
        !inTransaction &&
        supportsRetryableWrites(server) &&
        operation.canRetryWrite;

      const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);
      const hasWriteAspect = operation.hasAspect(Aspect.WRITE_OPERATION);

      if ((hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite)) {
        if (hasWriteAspect && willRetryWrite) {
          operation.options.willRetryWrite = true;
          session.incrementTransactionNumber();
        }

<<<<<<< HEAD
        operation.execute(server, session, callbackWithRetry);
        return;
      }
    }

    operation.execute(server, session, callback);
  });
}

function shouldRetryWrite(err: any) {
  return err instanceof MongoError && err.hasErrorLabel('RetryableWriteError');
}
=======
        return operation.execute(server, session, (error, result) => {
          if (error instanceof MongoError) {
            return retryOperation(error);
          } else if (error) {
            return callback(error);
          }
          callback(undefined, result);
        });
      }
    }

    return operation.execute(server, session, callback);
  });
}
>>>>>>> ee46ff854c6138d16fc5fe7b13fd0cd6ffcece5a
